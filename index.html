<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Neon Runner</title>
  <style>
    :root{--bg:#000;--player:#00f9ff;--ob:#ff00f0;--ui:#ffffff}
    html,body{height:100%;margin:0;background:var(--bg);display:flex;align-items:center;justify-content:center;font-family:Inter,system-ui,Arial,sans-serif}
    canvas{background:transparent;display:block;border-radius:8px;box-shadow:0 0 0 6px var(--ob)}
    .wrapper{display:flex;flex-direction:column;align-items:center;gap:10px}
    .hud{color:var(--ui);display:flex;gap:20px;font-weight:600}
    .btn{background:#111;border:1px solid #222;color:var(--ui);padding:8px 12px;border-radius:6px;cursor:pointer}
    .info{color:var(--player);font-size:14px;font-weight:bold;margin-bottom:8px;text-align:center}
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="info">Controls: Space / Up Arrow / Click or Tap — Jump. Down Arrow — Slam Down. Avoid magenta obstacles. Speed +10 each avoid.</div>
    <canvas id="game" width="800" height="420"></canvas>
    <div class="hud">
      <div id="score">Score: 0</div>
      <div id="highscore">High Score: 0</div>
      <div id="speed">Speed: 300 px/s</div>
      <button id="restart" class="btn">Restart</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  // Player
  const player = {
    x: 120,
    y: H - 90,
    size: 40,
    vy: 0,
    gravity: 1600, // px/s^2
    jumpVel: -900, // higher + faster jump
    onGround: true
  };

  // Obstacles
  let obstacles = [];
  let baseObstacleSpeed = 300; // px/s
  let obstacleSpeed = baseObstacleSpeed;
  const spawnGap = 1500; // ms between spawns at speed = base
  let lastSpawn = 0;

  let lastTime = performance.now();
  let running = true;
  let score = 0;
  let highScore = parseInt(localStorage.getItem('neonrunner_highscore') || '0', 10);

  const scoreEl = document.getElementById('score');
  const highScoreEl = document.getElementById('highscore');
  const speedEl = document.getElementById('speed');
  const restartBtn = document.getElementById('restart');

  function spawnObstacle(){
    const h = 30 + Math.random()*80;
    const w = 25; // fixed width
    const y = H - 60 - h; 
    obstacles.push({x: W + 20, y, w, h, counted:false});
  }

  function reset(){
    obstacles = [];
    obstacleSpeed = baseObstacleSpeed;
    lastSpawn = performance.now();
    score = 0;
    player.y = H - 90;
    player.vy = 0;
    player.onGround = true;
    running = true;
    lastTime = performance.now();
    updateHUD();
  }

  function updateHUD(){
    scoreEl.textContent = 'Score: ' + score;
    highScoreEl.textContent = 'High Score: ' + highScore;
    speedEl.textContent = 'Speed: ' + obstacleSpeed.toFixed(1) + ' px/s';
  }

  function jump(){
    if(player.onGround){
      player.vy = player.jumpVel;
      player.onGround = false;
    }
  }

  function slamDown(){
    if(!player.onGround){
      player.vy = 1000; 
    }
  }

  function rectsCollide(a,b){
    return !(a.x + a.size < b.x || a.x > b.x + b.w || a.y + a.size < b.y || a.y > b.y + b.h);
  }

  function gameOver(){
    running = false;
    if(score > highScore){
      highScore = score;
      localStorage.setItem('neonrunner_highscore', highScore);
    }
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = 'bold 34px Arial';
    ctx.fillStyle = '#ffcc00';
    ctx.fillText('GAME OVER', W/2, H/2 - 10);
    ctx.font = '16px Arial';
    ctx.fillStyle = '#fff';
    ctx.fillText('Score: ' + score, W/2, H/2 + 20);
    ctx.fillText('High Score: ' + highScore, W/2, H/2 + 45);
    ctx.restore();
  }

  function update(dt){
    // player physics
    player.vy += player.gravity * dt;
    player.y += player.vy * dt;
    const groundY = H - 60 - player.size; 
    if(player.y >= groundY){
      player.y = groundY;
      player.vy = 0;
      player.onGround = true;
    }

    // spawn logic
    const now = performance.now();
    const spawnInterval = Math.max(500, spawnGap * (baseObstacleSpeed / obstacleSpeed));
    if(now - lastSpawn > spawnInterval){
      spawnObstacle();
      lastSpawn = now;
    }

    // update obstacles
    for(let i=obstacles.length-1;i>=0;i--){
      const ob = obstacles[i];
      ob.x -= obstacleSpeed * dt;

      // scoring
      if(!ob.counted && ob.x + ob.w < player.x){
        ob.counted = true;
        score += 1;
        obstacleSpeed += 10; // now adds 10
        updateHUD();
      }

      // collision
      const playerRect = {x:player.x,y:player.y,size:player.size};
      if(rectsCollide(playerRect, ob)){
        running = false;
      }

      // remove off-screen
      if(ob.x + ob.w < -50) obstacles.splice(i,1);
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // background
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);

    // ground
    ctx.fillStyle = '#070707';
    ctx.fillRect(0, H - 60, W, 60);

    // player
    ctx.save();
    ctx.shadowColor = '#00f9ff';
    ctx.shadowBlur = 18;
    ctx.fillStyle = '#00f9ff';
    ctx.fillRect(player.x, player.y, player.size, player.size);
    ctx.restore();

    // obstacles
    for(const ob of obstacles){
      ctx.save();
      ctx.shadowColor = '#ff00f0';
      ctx.shadowBlur = 18;
      ctx.fillStyle = '#ff00f0';
      ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      ctx.restore();
    }

    // UI
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'left';
    ctx.fillText('Score: ' + score, 12, 18);
    ctx.fillText('High Score: ' + highScore, 12, 34);
    ctx.fillText('Speed: ' + obstacleSpeed.toFixed(1) + ' px/s', 12, 50);
  }

  function loop(now){
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;
    if(running){
      update(dt);
      draw();
      requestAnimationFrame(loop);
    } else {
      draw();
      gameOver();
    }
  }

  // input
  window.addEventListener('keydown', e => {
    if(e.code === 'Space' || e.code === 'ArrowUp'){
      e.preventDefault();
      jump();
    }
    if(e.code === 'ArrowDown'){
      e.preventDefault();
      slamDown();
    }
  });
  canvas.addEventListener('mousedown', e => { jump(); });
  canvas.addEventListener('touchstart', e => { e.preventDefault(); jump(); });

  restartBtn.addEventListener('click', () => { reset(); requestAnimationFrame(loop); });

  // initial
  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
